const { SlashCommandBuilder, EmbedBuilder, PermissionFlagsBits } = require('discord.js');
const { generateTranscript } = require('discord-html-transcripts');
const fs = require('fs').promises;
const path = require('path');

module.exports = {
    data: new SlashCommandBuilder()
        .setName('transcript')
        .setDescription('Generate a transcript of a ticket')
        .addStringOption(option =>
            option.setName('ticket-id')
                .setDescription('ID of the ticket to get transcript for (staff only)')
                .setRequired(false)),
    
    async execute(interaction) {
        const { client, channel } = interaction;
        const ticketId = interaction.options.getString('ticket-id');

        await interaction.deferReply({ ephemeral: true });

        // Check if user has permission to use this command
        const isStaff = interaction.member.roles.cache.some(role => 
            client.config.staffRoles.includes(role.id) || 
            role.id === client.config.adminRole
        );

        // If no ticket ID is provided, use current channel
        if (!ticketId) {
            const ticket = client.tickets.get(channel.id);
            if (!ticket) {
                return interaction.editReply({
                    content: 'This command can only be used in ticket channels!',
                    ephemeral: true
                });
            }

            // Check if user is ticket creator or staff
            if (ticket.userId !== interaction.user.id && !isStaff) {
                return interaction.editReply({
                    content: 'You can only generate transcripts for your own tickets!',
                    ephemeral: true
                });
            }

            await generateCurrentTranscript(interaction, ticket);
            return;
        }

        // If ticket ID is provided, only staff can access it
        if (!isStaff) {
            return interaction.editReply({
                content: 'Only staff members can generate transcripts for other tickets!',
                ephemeral: true
            });
        }

        // Get ticket from archives
        const archivedTicket = await client.dataManager.getArchivedTicket(ticketId);
        if (!archivedTicket) {
            return interaction.editReply({
                content: 'Could not find a ticket with that ID!',
                ephemeral: true
            });
        }

        await generateArchivedTranscript(interaction, archivedTicket);
    }
};

async function generateCurrentTranscript(interaction, ticket) {
    const { channel } = interaction;

    try {
        // Generate HTML transcript
        const transcript = await generateTranscript(channel, {
            limit: -1,
            returnBuffer: false,
            fileName: `transcript-${ticket.id}.html`,
            poweredBy: false
        });

        // Save transcript file
        const transcriptPath = path.join(process.cwd(), 'data', 'transcripts');
        await fs.mkdir(transcriptPath, { recursive: true });
        await fs.writeFile(
            path.join(transcriptPath, `transcript-${ticket.id}.html`),
            transcript
        );

        // Create transcript embed
        const embed = new EmbedBuilder()
            .setColor(interaction.client.config.embeds.color)
            .setTitle(`Transcript - Ticket #${ticket.id}`)
            .setDescription('Generated transcript of the current ticket.')
            .addFields(
                { name: 'Ticket Owner', value: `<@${ticket.userId}>`, inline: true },
                { name: 'Generated By', value: `<@${interaction.user.id}>`, inline: true },
                { name: 'Generated At', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: true }
            );

        // Send transcript
        await interaction.editReply({
            embeds: [embed],
            files: [transcript],
            ephemeral: true
        });
    } catch (error) {
        console.error('Error generating transcript:', error);
        await interaction.editReply({
            content: 'An error occurred while generating the transcript.',
            ephemeral: true
        });
    }
}

async function generateArchivedTranscript(interaction, ticket) {
    try {
        // Create transcript embed
        const embed = new EmbedBuilder()
            .setColor(interaction.client.config.embeds.color)
            .setTitle(`Transcript - Ticket #${ticket.id}`)
            .setDescription('Archived ticket transcript.')
            .addFields(
                { name: 'Ticket Owner', value: `<@${ticket.userId}>`, inline: true },
                { name: 'Created At', value: `<t:${Math.floor(new Date(ticket.createdAt).getTime() / 1000)}:F>`, inline: true },
                { name: 'Closed At', value: `<t:${Math.floor(new Date(ticket.closedAt).getTime() / 1000)}:F>`, inline: true },
                { name: 'Closed By', value: ticket.closedBy ? `<@${ticket.closedBy}>` : 'Unknown', inline: true },
                { name: 'Type', value: ticket.type || 'Unknown', inline: true },
                { name: 'Subject', value: ticket.subject || 'No subject', inline: true }
            );

        // Get transcript file if it exists
        const transcriptPath = path.join(
            process.cwd(),
            'data',
            'transcripts',
            `transcript-${ticket.id}.html`
        );

        let transcriptFile;
        try {
            transcriptFile = await fs.readFile(transcriptPath);
        } catch (error) {
            if (error.code === 'ENOENT') {
                embed.addFields({
                    name: 'Note',
                    value: 'Transcript file not found. This may be because the ticket was closed before transcript generation was implemented.',
                    inline: false
                });
            }
        }

        // Send response
        await interaction.editReply({
            embeds: [embed],
            files: transcriptFile ? [{ attachment: transcriptFile, name: `transcript-${ticket.id}.html` }] : [],
            ephemeral: true
        });
    } catch (error) {
        console.error('Error retrieving archived transcript:', error);
        await interaction.editReply({
            content: 'An error occurred while retrieving the transcript.',
            ephemeral: true
        });
    }
}